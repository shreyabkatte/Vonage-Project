"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const app_base_1 = __importDefault(require("../../app_base"));
const command_1 = require("@oclif/command");
const prompts_1 = require("prompts");
const helpers_1 = require("../../helpers");
const lodash_1 = require("lodash");
const cli_ux_1 = __importDefault(require("cli-ux"));
const chalk_1 = __importDefault(require("chalk"));
const kb_article = 'https://help.nexmo.com/hc/en-us/articles/4401914566036';
class ApplicationsUpdate extends app_base_1.default {
    setQuestions(list) {
        return list.map((application) => {
            return {
                title: `${application.name} | ${application.id}`,
                value: application.id
            };
        });
    }
    menuOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield prompts_1.prompt([
                {
                    type: 'select',
                    name: 'updateSelection',
                    message: 'Select Item to Update',
                    choices: [
                        { title: 'Application Name', value: 'name' },
                        { title: 'Voice Settings', value: 'voice' },
                        { title: 'Messages Settings', value: 'messages' },
                        { title: 'RTC Settings', value: 'rtc' },
                        { title: 'Cancel', value: 'cancel' },
                        { title: 'Update', value: 'update' }
                    ],
                }
            ]);
        });
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const flags = this.parsedFlags;
            const args = this.parsedArgs;
            let response = args;
            let oldAppState, newAppState;
            if (!response.appId) {
                let appData = yield this.allApplications;
                let appList = appData['_embedded'].applications;
                response = yield prompts_1.prompt([
                    {
                        type: 'autocomplete',
                        name: 'appId',
                        message: 'Select Application',
                        choices: this.setQuestions(appList),
                        initial: 0,
                    }
                ]);
            }
            oldAppState = yield this.getSingleApplication(response.appId);
            newAppState = Object.assign({}, oldAppState);
            if (Object.keys(flags).length > 0) {
                //merge flags into new object
                let tobeAssigned = Object.keys(flags).map((value, index) => {
                    return JSON.parse(flags[value]);
                }, []);
                lodash_1.merge(newAppState.capabilities, ...tobeAssigned);
            }
            else {
                //run interactive
                let menu = yield this.menuOptions();
                let updateItem = menu.updateSelection;
                while (updateItem !== 'update' && updateItem !== 'cancel') {
                    let { voice, messages, rtc, vbc } = oldAppState.capabilities;
                    if (updateItem === 'name') {
                        let { newAppName } = yield prompts_1.prompt([
                            {
                                type: 'text',
                                name: 'newAppName',
                                message: 'Update Name',
                                initial: oldAppState.name
                            }
                        ]);
                        newAppState.name = newAppName;
                    }
                    if (updateItem === 'voice') {
                        if (!voice)
                            voice = { webhooks: { answer_url: { address: '', http_method: '' }, event_url: { address: '', http_method: '' } } };
                        let { answer_url, event_url } = voice.webhooks;
                        let new_answer_url = yield helpers_1.webhookQuestions({ name: 'Answer Webhook', url: answer_url.address, method: answer_url.method });
                        let new_event_url = yield helpers_1.webhookQuestions({ name: 'Event Webhook', url: event_url.address, method: answer_url.method });
                        newAppState.capabilities.voice = {
                            webhooks: { answer_url: new_answer_url, event_url: new_event_url }
                        };
                    }
                    if (updateItem === 'messages') {
                        if (!messages)
                            messages = { webhooks: { inbound_url: { address: '', http_method: '' }, status_url: { address: '', http_method: '' } } };
                        let { inbound_url, status_url } = messages.webhooks;
                        let new_inbound_url = yield helpers_1.webhookQuestions({ name: 'Inbound Message Webhook', url: inbound_url.address, method: inbound_url.method });
                        let new_status_url = yield helpers_1.webhookQuestions({ name: 'Status Webhook', url: status_url.address, method: status_url.method });
                        newAppState.capabilities.messages = {
                            webhooks: { inbound_url: new_inbound_url, status_url: new_status_url }
                        };
                    }
                    if (updateItem === 'rtc') {
                        if (!rtc)
                            rtc = { webhooks: { event_url: { address: '', http_method: '' } } };
                        let { event_url } = rtc.webhooks;
                        let new_event_url = yield helpers_1.webhookQuestions({ name: 'Event Webhook', url: event_url.address, method: event_url.method });
                        newAppState.capabilities.rtc = {
                            webhooks: { event_url: new_event_url }
                        };
                    }
                    if (updateItem === 'vbc') {
                        this.log('Update VBC');
                    }
                    if (updateItem === 'key') {
                        this.log('Update Private Key');
                    }
                    let menu = yield this.menuOptions();
                    updateItem = menu.updateSelection;
                }
                if (updateItem === 'cancel') {
                    this.log(chalk_1.default.bold('Application update cancelled.'));
                    this.exit();
                }
            }
            cli_ux_1.default.action.start(chalk_1.default.bold(`Updating "${newAppState.name}"`));
            let output = yield this.updateApplication(newAppState);
            cli_ux_1.default.action.stop();
        });
    }
    catch(error) {
        const _super = Object.create(null, {
            catch: { get: () => super.catch }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.catch.call(this, error);
        });
    }
}
exports.default = ApplicationsUpdate;
ApplicationsUpdate.description = 'update a Vonage application';
ApplicationsUpdate.examples = [`vonage apps:update`, 'vonage apps:update APP_ID --voice_answer_url="https://www.example.com/answer'];
ApplicationsUpdate.flags = Object.assign(Object.assign({}, app_base_1.default.flags), { 'voice_answer_url': command_1.flags.string({
        description: 'Voice Answer Webhook URL Address',
        parse: input => `{"voice": {"webhooks": {"answer_url": {"address": "${input}"}}}}`
    }), 'voice_answer_http': command_1.flags.string({
        description: 'Voice Answer Webhook HTTP Method',
        options: ['GET', 'POST'],
        parse: input => `{"voice": {"webhooks": {"answer_url": {"http_method": "${input}"}}}}`
    }), 'voice_event_url': command_1.flags.string({
        description: 'Voice Event Webhook URL Address',
        parse: input => `{"voice": {"webhooks": {"event_url": {"address": "${input}"}}}}`
    }), 'voice_event_http': command_1.flags.string({
        description: 'Voice Event Webhook HTTP Method',
        options: ['GET', 'POST'],
        parse: input => `{"voice": {"webhooks": {"event_url": {"http_method": "${input}"}}}}`
    }), 'messages_inbound_url': command_1.flags.string({
        description: 'Messages Inbound Webhook URL Address',
        parse: input => `{"messages": {"webhooks": {"inbound_url": {"address": "${input}"}}}}`
    }), 'messages_inbound_http': command_1.flags.string({
        description: 'Messages Inbound Webhook HTTP Method',
        options: ['GET', 'POST'],
        parse: input => `{"messages": {"webhooks": {"inbound_url": {"http_method": "${input}"}}}}`
    }), 'messages_status_url': command_1.flags.string({
        description: 'Messages Status Webhook URL Address',
        parse: input => `{"messages": {"webhooks": {"status_url": {"address": "${input}"}}}}`
    }), 'messages_status_http': command_1.flags.string({
        description: 'Messages Status Webhook HTTP Method',
        options: ['GET', 'POST'],
        parse: input => `{"messages": {"webhooks": {"status_url": {"http_method": "${input}"}}}}`
    }), 'rtc_event_url': command_1.flags.string({
        description: 'RTC Event Webhook URL Address',
        parse: input => `{"rtc": {"webhooks": {"event_url": {"address": "${input}"}}}}`
    }), 'rtc_event_http': command_1.flags.string({
        description: 'RTC Event Webhook HTTP Method',
        options: ['GET', 'POST'],
        parse: input => `{"rtc": {"webhooks": {"event_url": {"http_method": "${input}"}}}}`
    }), 'vbc': command_1.flags.boolean({
        description: 'VBC Capabilities Enabled',
    }) });
ApplicationsUpdate.args = [
    { name: 'appId', required: false },
];
