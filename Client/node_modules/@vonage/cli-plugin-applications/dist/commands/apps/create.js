"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const app_base_1 = __importDefault(require("../../app_base"));
const command_1 = require("@oclif/command");
const prompts_1 = require("prompts");
const helpers_1 = require("../../helpers");
const unique_names_generator_1 = require("unique-names-generator");
const lodash_1 = require("lodash");
const fs_1 = require("fs");
const cli_ux_1 = __importDefault(require("cli-ux"));
const chalk_1 = __importDefault(require("chalk"));
const shortName = unique_names_generator_1.uniqueNamesGenerator({
    dictionaries: [unique_names_generator_1.adjectives, unique_names_generator_1.animals],
    length: 2
});
const kb_article = 'https://help.nexmo.com/hc/en-us/articles/4401914566036';
class ApplicationsCreate extends app_base_1.default {
    run() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const flags = this.parsedFlags;
            const args = this.parsedArgs;
            let response = { name: '', capabilities: {}, privacy: { improve_ai: false } };
            if (!args.name && Object.keys(flags).length > 0) {
                this.error(new Error('Argument \'name\' not provided'));
            }
            if (args.name && Object.keys(flags).length >= 0) {
                let tobeAssigned = Object.keys(flags).map((value, index) => {
                    if (value === "improve_ai") {
                        response.privacy.improve_ai = flags[value];
                        return;
                    }
                    return JSON.parse(flags[value]);
                }, []);
                lodash_1.merge(response.capabilities, ...tobeAssigned);
                response.name = args.name;
            }
            // if no flags or arguments provided, make interactive
            if (!args.name && Object.keys(flags).length === 0) {
                let general = yield prompts_1.prompt([
                    {
                        type: 'text',
                        name: 'name',
                        message: `Application Name`,
                        initial: shortName
                    }, {
                        type: 'multiselect',
                        name: 'selected_capabilities',
                        message: 'Select App Capabilities',
                        choices: [
                            { title: 'Voice', value: 'voice' },
                            { title: 'Messages', value: 'messages' },
                            { title: 'RTC', value: 'rtc' },
                            { title: 'VBC', value: 'vbc' }
                        ],
                        hint: '- Space to select. Return to submit'
                    }
                ]);
                response = Object.assign({}, response, general);
                if (((_a = response.selected_capabilities) === null || _a === void 0 ? void 0 : _a.indexOf('voice')) > -1) {
                    response.capabilities.voice = {};
                    let answer_url, event_url;
                    let voice = yield prompts_1.prompt({
                        type: 'confirm',
                        name: 'voice_webhooks_confirm',
                        message: 'Create voice webhooks?'
                    });
                    if (voice.voice_webhooks_confirm) {
                        answer_url = yield helpers_1.webhookQuestions({ name: 'Answer Webhook' });
                        event_url = yield helpers_1.webhookQuestions({ name: 'Event Webhook' });
                    }
                    else {
                        answer_url = { address: "https://www.sample.com/webhook/answer_url" };
                        event_url = { address: "https://www.sample.com/webhook/event_url" };
                    }
                    response.capabilities.voice = { webhooks: { answer_url, event_url } };
                }
                if (((_b = response.selected_capabilities) === null || _b === void 0 ? void 0 : _b.indexOf('messages')) > -1) {
                    response.capabilities.messages = {};
                    let inbound_url, status_url;
                    let messages = yield prompts_1.prompt({
                        type: 'confirm',
                        name: 'webhooks_confirm',
                        message: 'Create messages webhooks?'
                    });
                    if (messages.webhooks_confirm) {
                        inbound_url = yield helpers_1.webhookQuestions({ name: 'Inbound Message Webhook' });
                        status_url = yield helpers_1.webhookQuestions({ name: 'Status Webhook' });
                    }
                    else {
                        inbound_url = { address: "https://www.sample.com/webhook/inbound_url" };
                        status_url = { address: "https://www.sample.com/webhook/status_url" };
                    }
                    response.capabilities.messages = { webhooks: { status_url, inbound_url } };
                }
                if (((_c = response.selected_capabilities) === null || _c === void 0 ? void 0 : _c.indexOf('rtc')) > -1) {
                    response.capabilities.rtc = {};
                    let event_url;
                    let rtc = yield prompts_1.prompt({
                        type: 'confirm',
                        name: 'webhooks_confirm',
                        message: 'Create RTC webhook?'
                    });
                    if (rtc.webhooks_confirm) {
                        event_url = yield helpers_1.webhookQuestions({ name: 'Event Webhook' });
                    }
                    else {
                        event_url = { address: "https://www.sample.com/webhook/rtc_event_url" };
                    }
                    response.capabilities.rtc = { webhooks: { event_url } };
                }
                if (((_d = response.selected_capabilities) === null || _d === void 0 ? void 0 : _d.indexOf('vbc')) > -1) {
                    response.capabilities.vbc = {};
                }
                delete response.selected_capabilities;
                let improve_ai = yield prompts_1.prompt({
                    type: 'confirm',
                    name: 'improve_ai',
                    message: `Allow use of data for AI training? Read data collection disclosure - ${kb_article}`
                });
                response.privacy = improve_ai;
            }
            cli_ux_1.default.action.start(chalk_1.default.bold('Creating Application'), 'Initializing', { stdout: true });
            // create application 
            let output = yield this.createApplication(response);
            let keyFileName = helpers_1.sanitizeFileName(output.name);
            // write vonage.app file
            let vonage_app_file_path = `${process.cwd()}/vonage_app.json`;
            let vonage_private_key_file_path = `${process.cwd()}/${keyFileName.toLowerCase()}.key`;
            fs_1.writeFileSync(vonage_app_file_path, JSON.stringify({
                application_name: output.name,
                application_id: output.id,
                private_key: output.keys.private_key
            }, null, 2));
            fs_1.writeFileSync(vonage_private_key_file_path, output.keys.private_key);
            cli_ux_1.default.action.stop();
            let indent = '  ';
            this.log(chalk_1.default.magenta.underline.bold("Application Name:"), output.name);
            this.log('');
            this.log(chalk_1.default.magenta.underline.bold("Application ID:"), output.id);
            this.log('');
            let { voice, messages, rtc, vbc } = output.capabilities;
            if (voice) {
                let { event_url, answer_url } = voice.webhooks;
                this.log(chalk_1.default.magenta.underline.bold("Voice Settings"));
                this.log(indent, chalk_1.default.cyan.underline.bold("Event Webhook:"));
                this.log(indent, indent, chalk_1.default.bold('Address:'), event_url.address);
                this.log(indent, indent, chalk_1.default.bold('HTTP Method:'), event_url.http_method);
                this.log(indent, chalk_1.default.cyan.underline.bold("Answer Webhook:"));
                this.log(indent, indent, chalk_1.default.bold('Address:'), answer_url.address);
                this.log(indent, indent, chalk_1.default.bold('HTTP Method:'), answer_url.http_method);
                this.log('');
            }
            if (messages) {
                let { inbound_url, status_url } = messages.webhooks;
                this.log(chalk_1.default.magenta.underline.bold("Messages Settings"));
                this.log(indent, chalk_1.default.cyan.underline.bold("Inbound Webhook:"));
                this.log(indent, indent, chalk_1.default.bold('Address:'), inbound_url.address);
                this.log(indent, indent, chalk_1.default.bold('HTTP Method:'), inbound_url.http_method);
                this.log(indent, chalk_1.default.cyan.underline.bold("Status Webhook:"));
                this.log(indent, indent, chalk_1.default.bold('Address:'), status_url.address);
                this.log(indent, indent, chalk_1.default.bold('HTTP Method:'), status_url.http_method);
                this.log('');
            }
            if (rtc) {
                let { event_url } = rtc.webhooks;
                this.log(chalk_1.default.magenta.underline.bold("RTC Settings"));
                this.log(indent, chalk_1.default.cyan.underline.bold("Event Webhook:"));
                this.log(indent, indent, chalk_1.default.bold('Address:'), event_url.address);
                this.log(indent, indent, chalk_1.default.bold('HTTP Method:'), event_url.http_method);
                this.log('');
            }
            if (vbc) {
                this.log(chalk_1.default.magenta.underline.bold("VBC Settings"));
                this.log(chalk_1.default.bold("Enabled"));
                this.log('');
            }
            this.log(chalk_1.default.magenta.underline.bold("Public Key"));
            this.log(output.keys.public_key);
            this.log('');
            this.log(chalk_1.default.magenta.underline.bold("App Files"));
            this.log(chalk_1.default.bold('Vonage App File:'), vonage_app_file_path);
            this.log('');
            this.log(chalk_1.default.bold('Private Key File:'), vonage_private_key_file_path);
            this.log('');
            this.log(chalk_1.default.magenta.underline.bold("Improve AI:"), output.privacy.improve_ai);
            this.log('');
            this.exit();
        });
    }
    catch(error) {
        const _super = Object.create(null, {
            catch: { get: () => super.catch }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.catch.call(this, error);
        });
    }
}
exports.default = ApplicationsCreate;
ApplicationsCreate.description = 'create a new Vonage application';
ApplicationsCreate.examples = [
    'vonage apps:create', 'vonage apps:create APP_NAME --voice_answer_url=https://www.sample.com'
];
ApplicationsCreate.flags = Object.assign(Object.assign({}, app_base_1.default.flags), { 'voice_answer_url': command_1.flags.string({
        description: 'Voice Answer Webhook URL Address',
        dependsOn: ['voice_event_url'],
        parse: input => `{"voice": {"webhooks": {"answer_url": {"address": "${input}"}}}}`
    }), 'voice_answer_http': command_1.flags.string({
        description: 'Voice Answer Webhook HTTP Method',
        options: ['GET', 'POST'],
        dependsOn: ['voice_answer_url'],
        parse: input => `{"voice": {"webhooks": {"answer_url": {"http_method": "${input}"}}}}`
    }), 'voice_event_url': command_1.flags.string({
        description: 'Voice Event Webhook URL Address',
        dependsOn: ['voice_answer_url'],
        parse: input => `{"voice": {"webhooks": {"event_url": {"address": "${input}"}}}}`
    }), 'voice_event_http': command_1.flags.string({
        description: 'Voice Event Webhook HTTP Method',
        options: ['GET', 'POST'],
        dependsOn: ['voice_event_url'],
        parse: input => `{"voice": {"webhooks": {"event_url": {"http_method": "${input}"}}}}`
    }), 'messages_inbound_url': command_1.flags.string({
        description: 'Messages Inbound Webhook URL Address',
        parse: input => `{"messages": {"webhooks": {"inbound_url": {"address": "${input}"}}}}`
    }), 'messages_inbound_http': command_1.flags.string({
        description: 'Messages Inbound Webhook HTTP Method',
        options: ['GET', 'POST'],
        dependsOn: ['messages_inbound_url'],
        parse: input => `{"messages": {"webhooks": {"inbound_url": {"http_method": "${input}"}}}}`
    }), 'messages_status_url': command_1.flags.string({
        description: 'Messages Status Webhook URL Address',
        parse: input => `{"messages": {"webhooks": {"status_url": {"address": "${input}"}}}}`
    }), 'messages_status_http': command_1.flags.string({
        description: 'Messages Status Webhook HTTP Method',
        options: ['GET', 'POST'],
        dependsOn: ['messages_status_url'],
        parse: input => `{"messages": {"webhooks": {"status_url": {"http_method": "${input}"}}}}`
    }), 'rtc_event_url': command_1.flags.string({
        description: 'RTC Event Webhook URL Address',
        parse: input => `{"rtc": {"webhooks": {"event_url": {"address": "${input}"}}}}`
    }), 'rtc_event_http': command_1.flags.string({
        description: 'RTC Event Webhook HTTP Method',
        options: ['GET', 'POST'],
        dependsOn: ['rtc_event_url'],
        parse: input => `{"rtc": {"webhooks": {"event_url": {"http_method": "${input}"}}}}`
    }), 'vbc': command_1.flags.boolean({
        description: 'VBC Capabilities Enabled',
        parse: () => `{"vbc": {}}`
    }), 'improve_ai': command_1.flags.boolean({
        description: `Allow use of data for AI training? Read data collection disclosure - ${kb_article}`,
    }) });
ApplicationsCreate.args = [
    ...app_base_1.default.args,
    { name: 'name', required: false }
];
