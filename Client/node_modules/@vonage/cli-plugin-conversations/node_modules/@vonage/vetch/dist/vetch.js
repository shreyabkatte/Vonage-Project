"use strict";
// Copyright 2020 Vonage
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vetch = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const querystring_1 = require("querystring");
const lodash_1 = require("lodash");
const common_1 = require("./common");
class Vetch {
    constructor(defaults) {
        this.defaults = defaults || {};
    }
    _defaultAdapter(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield node_fetch_1.default(opts.url, opts);
            const data = yield this.getResponseData(opts, res);
            return this.createResponse(opts, res, data);
        });
    }
    request(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            opts = this.validateOpts(opts);
            try {
                let formattedResponse;
                formattedResponse = yield this._defaultAdapter(opts);
                if (!opts.checkStatus(formattedResponse.status)) {
                    throw new common_1.VetchError(`Request failed with status code ${formattedResponse.status}`, opts, formattedResponse);
                }
                return formattedResponse;
            }
            catch (e) {
                const err = e;
                throw err;
            }
        });
    }
    getResponseData(opts, res) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (opts.responseType) {
                case 'json': {
                    let data = yield res.text();
                    try {
                        data = JSON.parse(data);
                    }
                    catch (_a) {
                        // continue
                    }
                    return data;
                }
                default:
                    return res.text();
            }
        });
    }
    validateOpts(options) {
        const opts = lodash_1.merge({}, this.defaults, options);
        opts.headers = opts.headers || {};
        opts.checkStatus = this.checkStatus;
        opts.responseType = opts.responseType;
        if (!opts.url) {
            throw new Error('URL is required.');
        }
        const baseUrl = opts.baseUrl || opts.baseURL;
        if (baseUrl) {
            opts.url = baseUrl + opts.url;
        }
        if (opts.params) {
            let queryParams = querystring_1.stringify(opts.params);
            if (queryParams.startsWith('?')) {
                queryParams = queryParams.slice(1);
            }
            let prefix = opts.url.includes('?') ? '&' : '?';
            opts.url = `${opts.url}${prefix}${queryParams}`;
        }
        if (opts.data) {
            if (typeof opts.data === 'object') {
                opts.body = JSON.stringify(opts.data);
                opts.headers['Content-Type'] = 'application/json';
            }
            else {
                opts.body = opts.data;
            }
        }
        if (!opts.headers['Accept'] && opts.responseType === 'json') {
            opts.headers['Accept'] = 'application/json';
        }
        return opts;
    }
    checkStatus(status) {
        return status >= 200 && status < 300;
    }
    createResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            config: opts,
            data: data,
            headers,
            status: res.status,
            statusText: res.statusText,
            request: {
                responseUrl: res.url,
            },
        };
    }
}
exports.Vetch = Vetch;
